"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCjsToEsmTransformer = void 0;
const typescript_1 = __importDefault(require("typescript"));
/**
 * Transforms CommonJS calls/exports to ESM syntax.
 * If a source file is identified as using `require`, `module`, or `exports`,
 * it is wrapped with the following:
 * ```
 * [generated imports]
 * let exports = {}, module = { exports }
 *
 * [original code]
 *
 * export default module.exports
 * ```
 *
 * Each `require(...)` call is converted to a generated import statement
 * with a unique identifier.
 */
function createCjsToEsmTransformer(options = {}) {
    return (context) => (sourceFile) => transformSourceFile(sourceFile, context, options);
}
exports.createCjsToEsmTransformer = createCjsToEsmTransformer;
function transformSourceFile(sourceFile, context, { shouldTransform = () => true }) {
    if (sourceFile.statements.some((node) => typescript_1.default.isImportDeclaration(node) || typescript_1.default.isExportDeclaration(node))) {
        // file has esm, so avoid cjs conversion.
        return sourceFile;
    }
    let fileUsesCommonJs = false;
    const { factory } = context;
    const newImports = [];
    sourceFile = typescript_1.default.visitEachChild(sourceFile, visitCommonJS, context);
    if (fileUsesCommonJs) {
        const newStatements = [
            ...newImports,
            createCjsModuleDefinition(factory),
            ...sourceFile.statements,
            createCjsExportDefault(factory),
        ];
        sourceFile = factory.updateSourceFile(sourceFile, newStatements);
    }
    return sourceFile;
    function visitCommonJS(node) {
        if (typescript_1.default.isFunctionLike(node) &&
            node.parameters.some(({ name }) => typescript_1.default.isIdentifier(name) && name.text === 'require')) {
            // do no iterate into bodies of functions defining a `require` parameter.
            // mocha's bundle uses this pattern. avoid transforming `require` calls inside such functions.
            return node;
        }
        else if (typescript_1.default.isTryStatement(node)) {
            // heuristic for conditionally required libs (inside try/catch).
            // typescript bundle uses this pattern to require `source-map-support`.
            return node;
        }
        else if (isModuleExportsElementAccess(node) || isExportsPropertyAccess(node) || isTypeOfExports(node)) {
            fileUsesCommonJs = true;
        }
        else if (isCJsRequireCall(node) && shouldTransform(node.arguments[0].text)) {
            fileUsesCommonJs = true;
            const importIdentifier = createImportIdentifier(node, factory);
            newImports.push(factory.createImportDeclaration(undefined /* decorators */, undefined /* modifiers */, factory.createImportClause(false, importIdentifier, undefined /* namedBindings */), node.arguments[0]));
            // replace require call with identifier
            return importIdentifier;
        }
        return typescript_1.default.visitEachChild(node, visitCommonJS, context);
    }
}
// export default module.exports
function createCjsExportDefault(factory) {
    return factory.createExportDefault(factory.createPropertyAccessExpression(factory.createIdentifier('module'), 'exports'));
}
// unique identifier generation
function createImportIdentifier(node, factory) {
    const { parent } = node;
    if (parent && typescript_1.default.isVariableDeclaration(parent) && typescript_1.default.isIdentifier(parent.name)) {
        // var libName = require(...)
        // so use libName
        return factory.createUniqueName(parent.name.text);
    }
    else {
        // use _imported_1, _imported_2, etc
        return factory.createUniqueName('_imported');
    }
}
// let exports = {}, module = { exports }
function createCjsModuleDefinition(factory) {
    return factory.createVariableStatement(undefined /* modifiers */, factory.createVariableDeclarationList([
        factory.createVariableDeclaration('exports', undefined /* exclamationToken */, undefined /* type */, factory.createObjectLiteralExpression()),
        factory.createVariableDeclaration('module', undefined /* exclamationToken */, undefined /* type */, factory.createObjectLiteralExpression([factory.createShorthandPropertyAssignment('exports')])),
    ], typescript_1.default.NodeFlags.Let));
}
// require(...) calls with a single string argument
const isCJsRequireCall = (node) => typescript_1.default.isCallExpression(node) &&
    typescript_1.default.isIdentifier(node.expression) &&
    node.expression.text === 'require' &&
    node.arguments.length === 1 &&
    typescript_1.default.isStringLiteral(node.arguments[0]);
// module['exports']
const isModuleExportsElementAccess = (node) => typescript_1.default.isElementAccessExpression(node) &&
    typescript_1.default.isIdentifier(node.expression) &&
    node.expression.text === 'module' &&
    typescript_1.default.isStringLiteral(node.argumentExpression) &&
    node.argumentExpression.text === 'exports';
// module.exports OR exports.<something>
const isExportsPropertyAccess = (node) => typescript_1.default.isPropertyAccessExpression(node) &&
    typescript_1.default.isIdentifier(node.expression) &&
    ((node.expression.text === 'module' && node.name.text === 'exports') || node.expression.text === 'exports');
// typeof exports
const isTypeOfExports = (node) => typescript_1.default.isTypeOfExpression(node) && typescript_1.default.isIdentifier(node.expression) && node.expression.text === 'exports';
//# sourceMappingURL=cjs-to-esm-transformer.js.map