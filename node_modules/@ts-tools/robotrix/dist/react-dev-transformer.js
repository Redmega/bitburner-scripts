"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reactDevTransformer = void 0;
const typescript_1 = __importDefault(require("typescript"));
const SELF = '__self';
const SOURCE = '__source';
const JSX_FILENAME = '__jsxFileName';
/**
 * Transformer that adds meta-data which is used by React for development error messages.
 *
 * It adds the following attributes to all JSX elements:
 *  1. __self={this}
 *  2. __source={{ fileName: __jsxFileName, lineNumber: [jsx line number] }}
 *
 * if __source was added, the following declaration is prepended to source file:
 *   const __jsxFileName = [absolute file path]
 */
function reactDevTransformer(context) {
    const { factory } = context;
    return (sourceFile) => {
        const { fileName } = sourceFile; // absolute file path
        // we want to add the __jsxFileName const only if it is used in any added attribute
        let shouldAddFileNameConst = false;
        // file-wide unique identifier that would point to the fileName string literal
        const jsxFileNameIdentifier = factory.createUniqueName(JSX_FILENAME, typescript_1.default.GeneratedIdentifierFlags.Optimistic | typescript_1.default.GeneratedIdentifierFlags.FileLevel);
        // fist run the visitor, so it will mark whether we need to add fileName const declaration
        sourceFile = typescript_1.default.visitEachChild(sourceFile, addJSXMetadata, context);
        if (shouldAddFileNameConst) {
            sourceFile = addFileNameConst(sourceFile, jsxFileNameIdentifier, fileName, factory);
        }
        return sourceFile;
        function addJSXMetadata(node) {
            // we only transform jsx attributes nodes that have parent jsx elements
            if (!typescript_1.default.isJsxAttributes(node) || !node.parent) {
                return typescript_1.default.visitEachChild(node, addJSXMetadata, context);
            }
            const { userDefinedSelf, userDefinedSource } = findUserDefinedAttributes(node);
            const newAttributes = [];
            if (!userDefinedSelf) {
                newAttributes.push(createSelfAttribute(factory));
            }
            if (!userDefinedSource) {
                shouldAddFileNameConst = true;
                const parentJsx = typescript_1.default.isJsxSelfClosingElement(node.parent) ? node.parent : node.parent.parent;
                const pos = parentJsx.pos;
                const { line } = typescript_1.default.getLineAndCharacterOfPosition(sourceFile, pos);
                newAttributes.push(createSourceAttribute(createLocationObject(jsxFileNameIdentifier, line, factory), factory));
            }
            if (newAttributes.length) {
                // we actually created new attributes, so append them
                node = factory.updateJsxAttributes(node, node.properties.concat(newAttributes));
            }
            // if any of the attributes contain JSX elements, we want to transform them as well
            return typescript_1.default.visitEachChild(node, addJSXMetadata, context);
        }
    };
}
exports.reactDevTransformer = reactDevTransformer;
// iterate over existing properties to check whether user already defined one of the props
function findUserDefinedAttributes(node) {
    let userDefinedSelf = false;
    let userDefinedSource = false;
    for (const prop of node.properties) {
        const { name: propName } = prop;
        if (propName && (typescript_1.default.isIdentifier(propName) || typescript_1.default.isStringLiteral(propName))) {
            if (propName.text === SELF) {
                userDefinedSelf = true;
            }
            else if (propName.text === SOURCE) {
                userDefinedSource = true;
            }
        }
    }
    return { userDefinedSelf, userDefinedSource };
}
// __self={this}
function createSelfAttribute(factory) {
    return factory.createJsxAttribute(factory.createIdentifier(SELF), factory.createJsxExpression(undefined, factory.createThis()));
}
// __source={ [location-object] }
function createSourceAttribute(locationObj, factory) {
    return factory.createJsxAttribute(factory.createIdentifier(SOURCE), factory.createJsxExpression(undefined, locationObj));
}
// { fileName: [path-to-file], lineNumber: [element-line-number] }
function createLocationObject(jsxFileNameIdentifier, line, factory) {
    return factory.createObjectLiteralExpression([
        factory.createPropertyAssignment('fileName', jsxFileNameIdentifier // use the file-wide identifier for fileName value
        ),
        factory.createPropertyAssignment('lineNumber', factory.createNumericLiteral(String(line + 1))),
    ]);
}
// const __jsxFileName = "/path/to/file.ts"
function addFileNameConst(sourceFile, jsxFileNameIdentifier, fileName, factory) {
    const variableDecls = [
        factory.createVariableDeclaration(jsxFileNameIdentifier, undefined /* exclamationToken */, undefined /* type */, factory.createStringLiteral(fileName)),
    ];
    return insertStatementAfterImports(sourceFile, factory.createVariableStatement(undefined /* modifiers */, factory.createVariableDeclarationList(variableDecls, typescript_1.default.NodeFlags.Const)), factory);
}
// insert a new statement above the first non-import statement
function insertStatementAfterImports(sourceFile, statement, factory) {
    const { statements } = sourceFile;
    const nonImportIdx = statements.findIndex((s) => !typescript_1.default.isImportDeclaration(s));
    const newStatements = nonImportIdx === -1
        ? [statement, ...statements]
        : [...statements.slice(0, nonImportIdx), statement, ...statements.slice(nonImportIdx)];
    return factory.updateSourceFile(sourceFile, newStatements);
}
//# sourceMappingURL=react-dev-transformer.js.map